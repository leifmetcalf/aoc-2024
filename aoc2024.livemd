# Advent of Code 2024

## Common

[![Run in Livebook](https://livebook.dev/badge/v1/blue.svg)](https://livebook.dev/run?url=https%3A%2F%2Fraw.githubusercontent.com%2Fleifmetcalf%2Faoc-2024%2Frefs%2Fheads%2Ftrunk%2Faoc2024.livemd)

```elixir
defmodule TopologicalSort do
  def topological_sort(vertices, edges) do
    adj =
      Enum.reduce(edges, Map.new(vertices, &{&1, []}), fn
        {a, b}, adj -> Map.update!(adj, a, &[b | &1])
      end)

    n_parents =
      Enum.reduce(edges, Map.new(vertices, &{&1, 0}), fn
        {a, b}, n_parents -> Map.update!(n_parents, b, &(&1 + 1))
      end)

    orphans = Enum.filter(vertices, &(n_parents[&1] == 0))

    go(adj, n_parents, orphans, [])
    |> Enum.reverse()
  end

  defp go(adj, n_parents, orphans, acc) do
    case orphans do
      [] ->
        if length(acc) == Enum.count(adj), do: acc

      [v | orphans] ->
        {n_parents, orphans} =
          Enum.reduce(adj[v], {n_parents, orphans}, fn child, {n_parents, orphans} ->
            n_parents = Map.update!(n_parents, child, &(&1 - 1))

            orphans =
              if n_parents[child] == 0 do
                [child | orphans]
              else
                orphans
              end

            {n_parents, orphans}
          end)

        go(adj, n_parents, orphans, [v | acc])
    end
  end
end

defmodule Prelude do
  def parse_grid(input, pat \\ nil) do
    input
    |> String.split("\n", trim: true)
    |> Enum.map(fn row ->
      if(is_nil(pat), do: String.split(row), else: String.split(row, pat))
      |> Enum.map(&String.to_integer/1)
    end)
  end

  def transpose(xs) do
    List.zip(xs) |> Enum.map(&Tuple.to_list/1)
  end

  def grid_to_map(grid) do
    grid
    |> Enum.with_index(fn row, r -> row |> Enum.with_index(fn x, c -> {{r, c}, x} end) end)
    |> Enum.concat()
    |> Map.new()
  end

  def pairs(xs) do
    Enum.reduce(xs, {xs, []}, fn x, {[_ | rest], acc} ->
      {rest, [Enum.map(rest, &{x, &1}) | acc]}
    end)
    |> elem(1)
    |> Enum.reverse()
    |> Enum.concat()
  end

  def find_index_2d(grid, f) do
    Enum.find_value(Stream.with_index(grid), fn {row, r} ->
      if c = Enum.find_index(row, f), do: {r, c}
    end)
  end

  def contains_dup?(enumerable) do
    enumerable
    |> Enum.reduce_while(MapSet.new(), fn x, acc ->
      if x in acc, do: {:halt, :contains_dup}, else: {:cont, MapSet.put(acc, x)}
    end) == :contains_dup
  end

  def indices(enumerable) do
    Map.new(Stream.with_index(enumerable))
  end

  defdelegate topological_sort(vertices, edges), to: TopologicalSort
end
```

```elixir
import Prelude
```

## Day 1

```elixir
defmodule Day1 do
  def input() do
    File.read!("/home/leif/Documents/aoc/1")
  end
  def parse(input) do
    parse_grid(input) |> transpose()
  end
end
```

```elixir
defmodule Day1.Part1 do
  @doc """
  iex> Day1.input() |> Day1.Part1.go()
  1506483
  """
  def go(input) do
    Day1.parse(input)
    |> Enum.map(&Enum.sort/1)
    |> Enum.zip_with(fn [x, y] -> abs(x - y) end)
    |> Enum.sum()
  end
end
```

```elixir
defmodule Day1.Part2 do
  @doc """
  iex> Day1.input() |> Day1.Part2.go()
  23126924
  """
  def go(input) do
    [xs, ys] = Day1.parse(input)
    freqs = Enum.frequencies(ys)
    Enum.map(xs, &(&1 * Map.get(freqs, &1, 0))) |> Enum.sum()
  end
end
```

## Day 2

```elixir
defmodule Day2 do
  def input() do
    File.read!("/home/leif/Documents/aoc/2")
  end

  def parse(input) do
    parse_grid(input)
  end

  def unsafe_index(row) do
    Enum.chunk_every(row, 3, 1, :discard)
    |> Enum.find_index(fn [x, y, z] ->
      (y - x) * (z - y) <= 0 or abs(y - x) not in 1..3 or abs(z - y) not in 1..3
    end)
  end
end
```

```elixir
defmodule Day2.Part1 do
  @doc """
  iex> Day2.input() |> Day2.Part1.go()
  220
  """
  def go(input) do
    Day2.parse(input) |> Enum.count(&(Day2.unsafe_index(&1) |> is_nil()))
  end
end
```

```elixir
defmodule Day2.Part2 do
  @doc """
  iex> Day2.input() |> Day2.Part2.go()
  296
  """
  def go(input) do
    Day2.parse(input)
    |> Enum.count(fn row ->
      i = Day2.unsafe_index(row)

      is_nil(i) or
        Enum.any?(0..2, &(List.delete_at(row, i + &1) |> Day2.unsafe_index() |> is_nil()))
    end)
  end
end
```

## Day 3

```elixir
defmodule Day3 do
  def input() do
    File.read!("/home/leif/Documents/aoc/3")
  end
end
```

```elixir
defmodule Day3.Part1 do
  @doc """
  iex> Day3.input() |> Day3.Part1.go()
  166905464
  """
  def go(input) do
    Regex.scan(~r/mul\((\d+),(\d+)\)/, input, capture: :all_but_first)
    |> Enum.map(fn [x, y] -> String.to_integer(x) * String.to_integer(y) end)
    |> Enum.sum()
  end
end
```

```elixir
defmodule Day3.Part2 do
  @doc """
  iex> Day3.input() |> Day3.Part2.go()
  72948684
  """
  def go(input) do
    Regex.scan(~r/(mul)\((\d+),(\d+)\)|(do)\(\)|(don\'t)\(\)/, input, capture: :all_but_first)
    |> Enum.reduce({0, 1}, fn
      ["mul", x, y], {acc, mask} ->
        {acc + mask * String.to_integer(x) * String.to_integer(y), mask}

      ["", "", "", "do"], {acc, _} ->
        {acc, 1}

      ["", "", "", "", "don't"], {acc, _} ->
        {acc, 0}
    end)
    |> elem(0)
  end
end
```

## Day 4

```elixir
defmodule Day4 do
  def input() do
    File.read!("/home/leif/Documents/aoc/4")
  end

  def parse(input) do
    input
    |> String.split()
    |> Enum.map(fn line -> String.codepoints(line) |> Enum.map(&String.to_atom/1) end)
  end
end
```

```elixir
defmodule Day4.Part1 do
  @doc """
  iex> Day4.input() |> Day4.Part1.go()
  2644
  """
  def go(input) do
    grid = input |> Day4.parse()
    map = grid |> grid_to_map()

    for(
      r <- 0..(length(grid) - 1),
      c <- 0..(length(List.first(grid)) - 1),
      do:
        [
          [{r, c}, {r + 1, c}, {r + 2, c}, {r + 3, c}],
          [{r, c}, {r - 1, c}, {r - 2, c}, {r - 3, c}],
          [{r, c}, {r, c + 1}, {r, c + 2}, {r, c + 3}],
          [{r, c}, {r, c - 1}, {r, c - 2}, {r, c - 3}],
          [{r, c}, {r + 1, c + 1}, {r + 2, c + 2}, {r + 3, c + 3}],
          [{r, c}, {r + 1, c - 1}, {r + 2, c - 2}, {r + 3, c - 3}],
          [{r, c}, {r - 1, c - 1}, {r - 2, c - 2}, {r - 3, c - 3}],
          [{r, c}, {r - 1, c + 1}, {r - 2, c + 2}, {r - 3, c + 3}]
        ]
        |> Enum.count(fn line -> Enum.map(line, &map[&1]) == [:X, :M, :A, :S] end)
    )
    |> Enum.sum()
  end
end
```

```elixir
defmodule Day4.Part2 do
  @doc """
  iex> Day4.input() |> Day4.Part2.go()
  1952
  """
  def go(input) do
    grid = input |> Day4.parse()
    map = grid |> grid_to_map()

    for(
      r <- 0..(length(grid) - 1),
      c <- 0..(length(List.first(grid)) - 1),
      do:
        if Enum.map(
             [{r, c}, {r + 1, c + 1}, {r + 1, c - 1}, {r - 1, c + 1}, {r - 1, c - 1}],
             &map[&1]
           ) in [
             [:A, :M, :M, :S, :S],
             [:A, :M, :S, :M, :S],
             [:A, :S, :M, :S, :M],
             [:A, :S, :S, :M, :M]
           ] do
          1
        else
          0
        end
    )
    |> Enum.sum()
  end
end
```

## Day 5

```elixir
defmodule Day5 do
  def input() do
    File.read!("/home/leif/Documents/aoc/5")
  end

  def parse(input) do
    [rules, updates] = String.split(input, "\n\n")

    rules = parse_grid(rules, "|") |> Enum.map(&List.to_tuple/1)
    updates = parse_grid(updates, ",")

    {rules, updates}
  end

  def sorted?(update, rules) do
    indices = indices(update)

    Enum.all?(rules, fn {a, b} ->
      i = indices[a]
      j = indices[b]
      is_nil(i) or is_nil(j) or i < j
    end)
  end
end
```

```elixir
defmodule Day5.Part1 do
  @doc """
  iex> Day5.input() |> Day5.Part1.go()
  7074
  """
  def go(input) do
    {rules, updates} = input |> Day5.parse()

    rules = MapSet.new(rules)

    Enum.filter(updates, &Day5.sorted?(&1, rules))
    |> Enum.map(fn update -> Enum.at(update, Integer.floor_div(length(update), 2)) end)
    |> Enum.sum()
  end
end
```

```elixir
defmodule Day5.Part2 do
  @doc """
  iex> Day5.input() |> Day5.Part2.go()
  4828
  """
  def go(input) do
    {rules, updates} = input |> Day5.parse()

    rules = MapSet.new(rules)

    Enum.map(updates, fn update ->
      relevant_rules = Enum.filter(rules, fn {a, b} -> a in update and b in update end)

      if Day5.sorted?(update, rules) do
        0
      else
        sorted = topological_sort(update, relevant_rules)
        Enum.at(sorted, Integer.floor_div(length(sorted), 2))
      end
    end)
    |> Enum.sum()
  end
end
```

## Day 6

```elixir
defmodule Day6 do
  def input() do
    File.read!("/home/leif/Documents/aoc/6")
  end

  def parse(input) do
    input
    |> String.split()
    |> Enum.map(fn line -> String.to_charlist(line) end)
  end

  def wander(coords, guard_pos) do
    Stream.iterate({guard_pos, {-1, 0}}, fn {{r, c}, {dr, dc}} ->
      {dr, dc} =
        Stream.iterate({dr, dc}, fn {dr, dc} -> {dc, -dr} end)
        |> Enum.find(fn {dr, dc} -> coords[{r + dr, c + dc}] != ?# end)

      {{r + dr, c + dc}, {dr, dc}}
    end)
  end

  def trodden(coords, guard_pos) do
    Day6.wander(coords, guard_pos)
    |> Stream.map(&elem(&1, 0))
    |> Stream.uniq()
    |> Stream.take_while(&Map.has_key?(coords, &1))
  end
end
```

```elixir
defmodule Day6.Part1 do
  @doc"""
  iex> Day6.input() |> Day6.Part1.go()
  5239
  """
  def go(input) do
    grid = input |> Day6.parse()
    guard_pos = find_index_2d(grid, &(&1 == ?^))
    coords = grid_to_map(grid)
    Day6.trodden(coords, guard_pos) |> Enum.count()
  end
end
```

```elixir
defmodule Day6.Part2 do
  defp has_loop?(coords, guard_pos) do
    Day6.wander(coords, guard_pos)
    |> Stream.take_while(&Map.has_key?(coords, elem(&1, 0)))
    |> contains_dup?()
  end

  def go(input) do
    grid = input |> Day6.parse()
    guard_pos = find_index_2d(grid, &(&1 == ?^))
    coords = grid_to_map(grid)
    trodden = Day6.trodden(coords, guard_pos)

    Enum.count(
      trodden,
      &has_loop?(Map.put(coords, &1, ?#), guard_pos)
    )
  end
end
```
